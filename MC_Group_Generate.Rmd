---
title: "Generate MC Groups"
---

### Generate Groups for MC

Some code that generates groups for MC. It uses something akin to an adjacency matrix to weight pairings of people
as less likely to occur in this iteration the more that they've occurred in previous iterations.

The below output will generate three groups based on the algorithm I've devised and the current attendees. Not all possible
groups of 3 are considered as this is a prohibitively large number of possibilities, but 10,000 representative groupings
are considered. Additionally, if Haley and Alex are both in attendance, then they are forced to be in different groups, as
this is one of the constraints of the problem.

```{r, echo = FALSE}

#Create list of lists of all groups
all_dates <- list(
            list(c("Scott","Alex","Jesse","Amy","Kelsey","Holly","Tara","Matt"), #1/11/2023
             c("Arianna","Haley","Mike","Carol","Amanda"),
             c("Martin","Tracy","Lauren","Sam"))
)

generate_mc_groups <- function(attendees, all_dates){

#################################
### Generate adjacency matrix ###
#################################

#Initialize list of group members
full_members <- c("Alex",
             "Haley",
             "Scott",
             "Arianna",
             "Jesse",
             "Holly",
             "Russ",
             "Lauren",
             "Sam",
             "Bronson",
             "Mike",
             "Carol",
             "Steve",
             "Martin",
             "Jordan",
             "Tracy",
             "Amanda",
             "Tara",
             "Kelsey",
             "Amy",
             "Matt"
             )
members <- full_members[full_members %in% attendees]
alex_haley_here <- ifelse("Alex" %in% members & "Haley" %in% members, TRUE, FALSE)
group_dat <- data.frame(members = members, ID = 1:length(members))
#Function to generate adjacency matrix
gen_adj_matrix <- function(data){
  mat <- matrix(data = 0.01, nrow = nrow(data), ncol = nrow(data))
  diag(mat) <- 0
  return(mat)
}
#Function to iterate adjacency matrix
#Takes a list with 3 groups
iter_adj_matrix <- function(group_list, data, adj_mat){
  for(i in 1:length(group_list)){
    group_vec <- group_list[[i]]
    combs <- combn(group_vec,2)
    for(j in 1:ncol(combs)){
      this_pair <- combs[,j]
      these_IDs <- group_dat$ID[group_dat$members == this_pair[1] | group_dat$members == this_pair[2]]
      #Check to make sure both of these people are in the adjacency matrix
      if(length(these_IDs == 2)){
      adj_mat[these_IDs[1],these_IDs[2]] <- adj_mat[these_IDs[1],these_IDs[2]] + 1
      adj_mat[these_IDs[2],these_IDs[1]] <- adj_mat[these_IDs[2],these_IDs[1]] + 1
      }
    }
  }
  return(adj_mat)
}

#Generate adj matrix fully
updated_adj_mat <- function(data, date_data){
  adj_mat <- gen_adj_matrix(data)
  for(k in length(date_data)){
    adj_mat <- iter_adj_matrix(date_data[[k]], data, adj_mat)
  }
  return(adj_mat)
}

adj_mat <- updated_adj_mat(group_dat, all_dates)

##################################################
### Generate possible groups and probabilities ###
##################################################

#Generate "many" possible combinations of 3 group members - not all, because this is too computationally expensive
group_number_vec <- rep(1:3,length.out = nrow(group_dat))
poss_combos <- matrix(data = 0, nrow = 10000, ncol = length(group_number_vec))
for(l in 1:nrow(poss_combos)){
  invalid_sample <- 1
  while(invalid_sample){
    this_sample <- sample(group_number_vec, size = length(group_number_vec), replace = FALSE)
    #Check for Alex and Haley being in the same group, must be false if they are here
    invalid_sample <- ifelse(this_sample[1] == this_sample[2] & alex_haley_here, 1, 0)
  }
  poss_combos[l,] <- this_sample
}
#Generate list of lists of groups generated by the above
gen_groups <- function(this_sample, data){
  return(list(data$members[this_sample == 1],
              data$members[this_sample == 2],
              data$members[this_sample == 3]))
}
list_of_groups <-vector("list",10000)
for(l in 1:nrow(poss_combos)){
  list_of_groups[[l]] <- gen_groups(poss_combos[l,],group_dat)
}
#Generate probabilities for each of these possible groups
sum_adj_mat <- function(group_list, adj_mat){
  adj_sum <- 0
  for(i in 1:length(group_list)){
    group_vec <- group_list[[i]]
    combs <- combn(group_vec,2)
    for(j in 1:ncol(combs)){
      this_pair <- combs[,j]
      these_IDs <- group_dat$ID[group_dat$members == this_pair[1] | group_dat$members == this_pair[2]]
      #Check to make sure both of these people are in the adjacency matrix
      if(length(these_IDs == 2)){
      adj_sum <- adj_sum + adj_mat[these_IDs[1],these_IDs[2]]
      adj_sum <- adj_sum + adj_mat[these_IDs[2],these_IDs[1]]
      }
    }
  }
  return(adj_sum)
}
prob_data <- data.frame(adj_sum = numeric(length(list_of_groups)),
                        recip_adj_sum = numeric(length(list_of_groups)))
for(l in 1:length(list_of_groups)){
  prob_data$adj_sum[l] <- sum_adj_mat(list_of_groups[[l]], adj_mat)
  prob_data$recip_adj_sum[l] <- 1/prob_data$adj_sum[l]
}
#Get final probabilities
prob_data$probs <- prob_data$recip_adj_sum/sum(prob_data$recip_adj_sum)

################################
### Choose group and display ###
################################

#Get group that is chosen
chosen_arrange <- sample(1:length(list_of_groups), size = 1, replace = FALSE, prob = prob_data$probs)
#message(list_of_groups[[chosen_arrange]])
cat("Group 1: ", list_of_groups[[chosen_arrange]][[1]],"\n")
cat("Group 2: ", list_of_groups[[chosen_arrange]][[2]],"\n")
cat("Group 3: ", list_of_groups[[chosen_arrange]][[3]],"\n")
}
```

```{r}
#########################
### Run for this week ###
#########################

attendees <- c("Alex","Haley","Scott","Arianna","Jesse","Holly","Russ","Lauren","Sam","Bronson",
                  "Mike","Carol","Steve","Martin","Jordan","Tracy","Amanda","Tara","Kelsey","Amy","Matt")

generate_mc_groups(attendees, all_dates)

```
